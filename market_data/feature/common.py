import abc
from typing import List, Optional
from market_data.feature.param import FeatureParam

import numpy as np
import pandas as pd


class Feature(metaclass=abc.ABCMeta):
    """Base feature class."""
    
    @staticmethod
    @abc.abstractmethod
    def calculate(df: pd.DataFrame, params: Optional[FeatureParam] = None) -> pd.DataFrame:
        """
        Calculate feature.
            
        Returns:
            DataFrame with calculated feature.
        """
        pass
    
    @classmethod
    def get_columns(cls, params: Optional[FeatureParam] = None) -> List[str]:
        """
        Get the list of column names that will be generated by this feature.
        
        This method creates a minimal dummy DataFrame and runs the calculate method
        to determine which columns are generated.
        
        Args:
            params: Feature parameters that determine which columns are generated
            
        Returns:
            List of column names that will be added to the DataFrame
        """
        # Create a minimal dummy DataFrame with required columns
        # Using more rows to handle calculations that need sufficient data
        periods = 100
        dummy_data = {
            'timestamp': pd.date_range('2024-01-01', periods=periods, freq='1min'),
            'symbol': ['TEST'] * periods,
            'open': np.random.uniform(99, 101, periods),
            'high': np.random.uniform(101, 103, periods),
            'low': np.random.uniform(97, 99, periods),
            'close': np.random.uniform(99, 101, periods),
            'volume': np.random.uniform(900000, 1100000, periods)
        }
        
        dummy_df = pd.DataFrame(dummy_data)
        dummy_df = dummy_df.set_index('timestamp')
        
        # Calculate features with the dummy data
        result_df = cls.calculate(dummy_df, params)
        
        # Get column names (excluding 'symbol' which might be in columns)
        columns = [col for col in result_df.columns if col != 'symbol']
        return columns
